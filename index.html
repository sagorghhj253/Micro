<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>HemaScan Pro - Advanced Clinical Live Blood Cell Analysis</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&family=Exo+2:wght@300;400;600;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00ffcc;
            --primary-dark: #00d9a8;
            --secondary: #ff3d71;
            --accent: #ffd93d;
            --clinical-green: #4CAF50;
            --clinical-blue: #2196F3;
            --clinical-red: #f44336;
            --clinical-purple: #9C27B0;
            --clinical-cyan: #00BCD4;
            --clinical-orange: #FF9800;
            --dark: #050a14;
            --dark-surface: #0d1520;
            --dark-elevated: #15202e;
            --dark-card: #1a2838;
            --text: #ffffff;
            --text-muted: #7a92b0;
            --success: #00ff88;
            --warning: #ffab00;
            --error: #ff3366;
            --grid: rgba(0, 255, 204, 0.08);
            --glow: rgba(0, 255, 204, 0.4);
            --clinical-glow: rgba(76, 175, 80, 0.4);
        }

        body {
            font-family: 'Exo 2', sans-serif;
            background: var(--dark);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* Hexagonal grid background pattern */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: 
                repeating-linear-gradient(0deg, var(--grid) 0px, transparent 1px, transparent 40px, var(--grid) 41px),
                repeating-linear-gradient(60deg, var(--grid) 0px, transparent 1px, transparent 40px, var(--grid) 41px),
                repeating-linear-gradient(120deg, var(--grid) 0px, transparent 1px, transparent 40px, var(--grid) 41px);
            animation: hexMove 30s linear infinite;
            pointer-events: none;
            z-index: 0;
            opacity: 0.4;
        }

        @keyframes hexMove {
            0% { transform: translate(0, 0); }
            100% { transform: translate(40px, 40px); }
        }

        .clinical-badge {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--clinical-green), var(--clinical-blue));
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 1px;
            z-index: 1000;
            box-shadow: 0 0 20px var(--clinical-glow);
            border: 1px solid var(--clinical-green);
        }

        .scan-line {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
            animation: scanMove 4s linear infinite;
            pointer-events: none;
            z-index: 100;
            opacity: 0.6;
        }

        @keyframes scanMove {
            0% { top: 0; }
            100% { top: 100%; }
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 24px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            animation: fadeInDown 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .logo {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 16px;
            margin-bottom: 12px;
        }

        .logo-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--clinical-green), var(--clinical-blue));
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            box-shadow: 0 0 40px var(--clinical-glow);
            animation: logoSpin 20s linear infinite;
            position: relative;
        }

        .logo-icon::before {
            content: '';
            position: absolute;
            inset: -4px;
            border-radius: 18px;
            background: linear-gradient(135deg, var(--clinical-green), var(--clinical-blue));
            opacity: 0.3;
            filter: blur(8px);
            z-index: -1;
        }

        @keyframes logoSpin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 36px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--clinical-green) 0%, var(--clinical-blue) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .subtitle {
            font-size: 14px;
            color: var(--text-muted);
            font-weight: 400;
            letter-spacing: 2px;
            text-transform: uppercase;
            margin-top: 8px;
        }

        .version-badge {
            display: inline-block;
            padding: 6px 12px;
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid var(--clinical-green);
            border-radius: 20px;
            font-size: 11px;
            font-family: 'Orbitron', sans-serif;
            color: var(--clinical-green);
            margin-top: 12px;
            letter-spacing: 1px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        .card {
            background: var(--dark-surface);
            border-radius: 24px;
            padding: 28px;
            border: 1px solid rgba(76, 175, 80, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            position: relative;
            overflow: hidden;
            animation: fadeInUp 0.8s cubic-bezier(0.16, 1, 0.3, 1);
            animation-fill-mode: both;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, transparent, var(--clinical-green), transparent);
            animation: shimmer 3s linear infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card:nth-child(1) { animation-delay: 0.1s; }
        .card:nth-child(2) { animation-delay: 0.2s; }
        .card:nth-child(3) { animation-delay: 0.3s; }
        .card:nth-child(4) { animation-delay: 0.4s; }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .card-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 18px;
            font-weight: 600;
            color: var(--clinical-green);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-badge {
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-badge.live {
            background: rgba(76, 175, 80, 0.15);
            color: var(--clinical-green);
            border: 1px solid var(--clinical-green);
            animation: livePulse 2s infinite;
        }

        @keyframes livePulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-badge.ready {
            background: rgba(0, 255, 136, 0.15);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .status-badge.processing {
            background: rgba(255, 171, 0, 0.15);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .status-badge.complete {
            background: rgba(33, 150, 243, 0.15);
            color: var(--clinical-blue);
            border: 1px solid var(--clinical-blue);
        }

        .status-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .video-container {
            position: relative;
            width: 100%;
            border-radius: 16px;
            overflow: hidden;
            background: var(--dark);
            aspect-ratio: 4/3;
            border: 2px solid var(--clinical-green);
            box-shadow: 0 0 40px var(--clinical-glow);
        }

        #video, #canvas, #processedCanvas {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        #canvas, #processedCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        #processedCanvas {
            z-index: 2;
        }

        .live-detection-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--clinical-green);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            z-index: 10;
        }

        .fps-counter {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--clinical-blue);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            z-index: 10;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(5, 10, 20, 0.9);
            backdrop-filter: blur(10px);
            z-index: 5;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(76, 175, 80, 0.2);
            border-top-color: var(--clinical-green);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        button {
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:active::before {
            width: 400px;
            height: 400px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--clinical-green), #2E7D32);
            color: white;
            box-shadow: 0 4px 20px var(--clinical-glow);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px var(--clinical-glow);
        }

        .btn-primary:disabled {
            background: var(--dark-elevated);
            color: var(--text-muted);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background: var(--dark-elevated);
            color: var(--text);
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .btn-secondary:hover {
            background: var(--dark-card);
            border-color: var(--clinical-green);
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.2);
        }

        .btn-accent {
            background: linear-gradient(135deg, var(--clinical-blue), #1565C0);
            color: white;
            box-shadow: 0 4px 20px rgba(33, 150, 243, 0.4);
        }

        .btn-accent:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(33, 150, 243, 0.6);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--clinical-red), #C62828);
            color: white;
            box-shadow: 0 4px 20px rgba(244, 67, 54, 0.4);
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(244, 67, 54, 0.6);
        }

        .btn-purple {
            background: linear-gradient(135deg, var(--clinical-purple), #7B1FA2);
            color: white;
            box-shadow: 0 4px 20px rgba(156, 39, 176, 0.4);
        }

        .btn-purple:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 30px rgba(156, 39, 176, 0.6);
        }

        .settings-grid {
            display: grid;
            gap: 16px;
        }

        .setting-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 16px;
            background: var(--dark-elevated);
            border-radius: 12px;
            border: 1px solid rgba(76, 175, 80, 0.1);
        }

        .setting-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
        }

        .setting-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--clinical-green);
            background: rgba(76, 175, 80, 0.1);
            padding: 4px 12px;
            border-radius: 8px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--dark-elevated);
            border-radius: 3px;
            outline: none;
            border: 1px solid rgba(76, 175, 80, 0.2);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--clinical-green), var(--clinical-blue));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--clinical-glow);
        }

        input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--clinical-green);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--dark-elevated);
            border-radius: 13px;
            border: 1px solid rgba(76, 175, 80, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .toggle-switch.active {
            background: linear-gradient(135deg, var(--clinical-green), var(--clinical-blue));
            border-color: var(--clinical-green);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 20px;
            height: 20px;
            background: var(--text);
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .toggle-switch.active::after {
            left: 26px;
            background: var(--dark);
        }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .result-card {
            background: var(--dark-elevated);
            border-radius: 16px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(76, 175, 80, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .result-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--clinical-green), transparent);
        }

        .result-card.live-update {
            animation: resultUpdate 0.5s ease;
        }

        @keyframes resultUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .result-card:hover {
            transform: translateY(-4px);
            border-color: var(--clinical-green);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.2);
        }

        .result-icon {
            font-size: 32px;
            margin-bottom: 12px;
        }

        .result-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
            margin-bottom: 8px;
            font-weight: 600;
        }

        .result-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 800;
            background: linear-gradient(135deg, var(--clinical-green), var(--clinical-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
            margin-bottom: 4px;
        }

        .result-subtext {
            font-size: 11px;
            color: var(--text-muted);
        }

        .result-change {
            font-size: 10px;
            margin-top: 4px;
            font-family: 'Orbitron', sans-serif;
        }

        .result-change.positive {
            color: var(--clinical-green);
        }

        .result-change.negative {
            color: var(--clinical-red);
        }

        .clinical-metrics {
            display: grid;
            gap: 12px;
            margin-top: 20px;
        }

        .metric-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: var(--dark-elevated);
            border-radius: 10px;
            border-left: 4px solid var(--clinical-green);
        }

        .metric-label {
            font-size: 12px;
            color: var(--text);
            font-weight: 600;
        }

        .metric-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            font-weight: 600;
            color: var(--clinical-green);
        }

        .metric-range {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .metric-status {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        .metric-status.normal {
            background: rgba(76, 175, 80, 0.1);
            color: var(--clinical-green);
            border: 1px solid var(--clinical-green);
        }

        .metric-status.warning {
            background: rgba(255, 171, 0, 0.1);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .metric-status.critical {
            background: rgba(244, 67, 54, 0.1);
            color: var(--clinical-red);
            border: 1px solid var(--clinical-red);
        }

        .data-export {
            background: var(--dark-elevated);
            border-radius: 12px;
            padding: 16px;
            margin-top: 20px;
            border: 1px solid rgba(76, 175, 80, 0.1);
        }

        .export-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 12px;
        }

        .export-btn {
            padding: 12px;
            background: var(--dark-card);
            border: 1px solid rgba(76, 175, 80, 0.2);
            border-radius: 8px;
            color: var(--text);
            font-family: 'Exo 2', sans-serif;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .export-btn:hover {
            background: var(--clinical-green);
            color: var(--dark);
            border-color: var(--clinical-green);
        }

        .hidden {
            display: none !important;
        }

        .full-width {
            grid-column: 1 / -1;
        }

        /* Image Processing Controls */
        .filters-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .filter-btn {
            padding: 12px;
            background: var(--dark-card);
            border: 1px solid var(--clinical-purple);
            border-radius: 8px;
            color: var(--text);
            font-family: 'Exo 2', sans-serif;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .filter-btn:hover {
            background: var(--clinical-purple);
            color: var(--dark);
            transform: translateY(-2px);
        }

        .filter-btn.active {
            background: var(--clinical-purple);
            color: white;
            box-shadow: 0 0 20px rgba(156, 39, 176, 0.4);
        }

        .processing-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(76, 175, 80, 0.2);
            padding-bottom: 12px;
        }

        .tab-btn {
            padding: 8px 16px;
            background: var(--dark-elevated);
            border: 1px solid rgba(76, 175, 80, 0.2);
            border-radius: 8px;
            color: var(--text-muted);
            font-family: 'Exo 2', sans-serif;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab-btn.active {
            background: var(--clinical-blue);
            color: white;
            border-color: var(--clinical-blue);
        }

        .histogram-container {
            height: 200px;
            background: var(--dark-elevated);
            border-radius: 12px;
            margin-top: 20px;
            padding: 16px;
            position: relative;
        }

        .histogram-canvas {
            width: 100%;
            height: 100%;
        }

        .image-upload {
            border: 2px dashed var(--clinical-blue);
            border-radius: 16px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 20px;
            background: rgba(33, 150, 243, 0.05);
        }

        .image-upload:hover {
            background: rgba(33, 150, 243, 0.1);
            border-color: var(--clinical-cyan);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 16px;
            color: var(--clinical-blue);
        }

        .upload-text {
            font-size: 14px;
            color: var(--text-muted);
            margin-bottom: 8px;
        }

        .upload-subtext {
            font-size: 12px;
            color: var(--text-muted);
            opacity: 0.7;
        }

        .image-preview {
            display: none;
            max-width: 100%;
            max-height: 300px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px solid var(--clinical-green);
        }

        .processing-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-label {
            font-size: 12px;
            color: var(--text);
            display: flex;
            justify-content: space-between;
        }

        .slider-value {
            font-family: 'Orbitron', sans-serif;
            color: var(--clinical-green);
            font-size: 11px;
        }

        /* Dual Display */
        .dual-display {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .display-card {
            background: var(--dark-elevated);
            border-radius: 16px;
            padding: 16px;
            border: 1px solid rgba(76, 175, 80, 0.1);
        }

        .display-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            color: var(--clinical-green);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .display-canvas {
            width: 100%;
            height: 200px;
            background: var(--dark);
            border-radius: 8px;
            border: 1px solid rgba(76, 175, 80, 0.2);
        }

        footer {
            text-align: center;
            margin-top: 60px;
            padding: 30px;
            font-size: 12px;
            color: var(--text-muted);
            opacity: 0;
            animation: fadeIn 1s ease-out 1s forwards;
            border-top: 1px solid rgba(76, 175, 80, 0.1);
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .dual-display {
                grid-template-columns: 1fr;
            }
            
            .filters-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 16px;
            }

            h1 {
                font-size: 28px;
            }

            .card {
                padding: 20px;
            }

            .results-grid {
                grid-template-columns: 1fr;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .export-buttons {
                grid-template-columns: 1fr;
            }

            .filters-grid {
                grid-template-columns: 1fr;
            }

            .processing-controls {
                grid-template-columns: 1fr;
            }
        }

        /* Loading OpenCV */
        .opencv-loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--dark-surface);
            padding: 40px 50px;
            border-radius: 24px;
            border: 2px solid var(--clinical-green);
            box-shadow: 0 0 60px var(--clinical-glow);
            z-index: 2000;
            text-align: center;
        }

        .opencv-loading-spinner {
            width: 80px;
            height: 80px;
            border: 5px solid rgba(76, 175, 80, 0.2);
            border-top-color: var(--clinical-green);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: var(--dark-elevated);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 16px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--clinical-green), var(--clinical-blue));
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--clinical-glow);
        }

        .trial-info {
            background: linear-gradient(135deg, rgba(33, 150, 243, 0.1), rgba(76, 175, 80, 0.1));
            border-radius: 12px;
            padding: 16px;
            margin-top: 20px;
            border: 1px solid var(--clinical-blue);
        }

        .trial-header {
            font-family: 'Orbitron', sans-serif;
            color: var(--clinical-blue);
            font-size: 14px;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-top: 20px;
        }

        .option-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: var(--dark-elevated);
            border-radius: 8px;
            border: 1px solid rgba(76, 175, 80, 0.1);
        }
    </style>
</head>
<body>
    <div class="clinical-badge">ADVANCED CLINICAL MODE</div>
    <div class="scan-line"></div>

    <div id="opencvLoader" class="opencv-loading">
        <div class="opencv-loading-spinner"></div>
        <div style="font-family: 'Orbitron', sans-serif; font-weight: 600; margin-bottom: 12px; font-size: 18px;">INITIALIZING ADVANCED PROCESSING</div>
        <div style="font-size: 14px; color: var(--text-muted);">Loading OpenCV with Advanced Filters...</div>
        <div class="progress-bar">
            <div class="progress-fill" style="width: 0%;"></div>
        </div>
    </div>

    <div class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">üß¨</div>
                <div>
                    <h1>HemaScan Pro Advanced</h1>
                </div>
            </div>
            <p class="subtitle">Advanced Blood Cell Analysis with Image Processing</p>
            <span class="version-badge">v4.0 - Advanced Processing Edition</span>
        </header>

        <div class="main-grid">
            <!-- Left Column: Live Detection & Processing -->
            <div>
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">üî¨ Live Detection & Processing</div>
                        <div class="status-badge ready" id="cameraStatus">
                            <span class="status-dot"></span>
                            <span id="statusText">Initializing</span>
                        </div>
                    </div>

                    <div class="processing-tabs">
                        <button class="tab-btn active" data-tab="camera">üì∑ Live Camera</button>
                        <button class="tab-btn" data-tab="upload">üìÅ Upload Image</button>
                        <button class="tab-btn" data-tab="processed">üñºÔ∏è Processed View</button>
                    </div>

                    <!-- Camera View -->
                    <div class="tab-content active" id="cameraTab">
                        <div class="video-container">
                            <video id="video" autoplay playsinline></video>
                            <canvas id="canvas"></canvas>
                            <canvas id="processedCanvas" class="hidden"></canvas>
                            <div class="live-detection-overlay">LIVE DETECTION</div>
                            <div class="fps-counter">FPS: <span id="fpsCounter">0</span></div>
                            <div id="videoOverlay" class="video-overlay">
                                <div class="loading-spinner"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Upload View -->
                    <div class="tab-content hidden" id="uploadTab">
                        <div class="image-upload" id="imageUpload">
                            <div class="upload-icon">üìÅ</div>
                            <div class="upload-text">Click to upload blood sample image</div>
                            <div class="upload-subtext">Supports JPG, PNG, BMP up to 10MB</div>
                            <input type="file" id="fileInput" accept="image/*" style="display: none;">
                        </div>
                        <img id="imagePreview" class="image-preview" alt="Uploaded Image">
                    </div>

                    <!-- Processed View -->
                    <div class="tab-content hidden" id="processedTab">
                        <div class="dual-display">
                            <div class="display-card">
                                <div class="display-title">Original</div>
                                <canvas id="originalCanvas" class="display-canvas"></canvas>
                            </div>
                            <div class="display-card">
                                <div class="display-title">Processed</div>
                                <canvas id="filterCanvas" class="display-canvas"></canvas>
                            </div>
                        </div>
                        <div class="histogram-container">
                            <canvas id="histogramCanvas" class="histogram-canvas"></canvas>
                        </div>
                    </div>

                    <div class="controls">
                        <button id="startLiveBtn" class="btn-primary">
                            ‚ñ∂Ô∏è START LIVE
                        </button>
                        <button id="stopLiveBtn" class="btn-warning hidden">
                            ‚è∏Ô∏è STOP LIVE
                        </button>
                        <button id="captureBtn" class="btn-accent" disabled>
                            üì∏ CAPTURE SNAPSHOT
                        </button>
                        <button id="resetBtn" class="btn-secondary">
                            üîÑ RESET
                        </button>
                        <button id="analyzeUploadBtn" class="btn-purple">
                            üîç ANALYZE IMAGE
                        </button>
                    </div>
                </div>

                <div class="card">
                    <div class="card-header">
                        <div class="card-title">‚öôÔ∏è Advanced Processing Filters</div>
                    </div>

                    <div class="filters-grid">
                        <button class="filter-btn" data-filter="gaussian">Gaussian Blur</button>
                        <button class="filter-btn" data-filter="median">Median Filter</button>
                        <button class="filter-btn" data-filter="bilateral">Bilateral Filter</button>
                        <button class="filter-btn" data-filter="contrast">Contrast Enhancement</button>
                        <button class="filter-btn" data-filter="colorspace">Color Space Convert</button>
                        <button class="filter-btn" data-filter="segmentation">Segmentation</button>
                        <button class="filter-btn" data-filter="canny">Canny Edge</button>
                        <button class="filter-btn" data-filter="morphology">Morphology</button>
                        <button class="filter-btn" data-filter="adaptive">Adaptive Threshold</button>
                    </div>

                    <div class="processing-controls">
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Kernel Size</span>
                                <span class="slider-value" id="kernelValue">3</span>
                            </div>
                            <input type="range" id="kernelSlider" min="1" max="31" value="3" step="2">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Sigma</span>
                                <span class="slider-value" id="sigmaValue">1.5</span>
                            </div>
                            <input type="range" id="sigmaSlider" min="0.1" max="5" value="1.5" step="0.1">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Threshold 1</span>
                                <span class="slider-value" id="threshold1Value">50</span>
                            </div>
                            <input type="range" id="threshold1Slider" min="0" max="255" value="50">
                        </div>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Threshold 2</span>
                                <span class="slider-value" id="threshold2Value">150</span>
                            </div>
                            <input type="range" id="threshold2Slider" min="0" max="255" value="150">
                        </div>
                    </div>

                    <div class="filter-options">
                        <div class="option-item">
                            <span>Show Histogram</span>
                            <div class="toggle-switch active" id="histogramToggle"></div>
                        </div>
                        <div class="option-item">
                            <span>Auto Apply</span>
                            <div class="toggle-switch" id="autoApplyToggle"></div>
                        </div>
                        <div class="option-item">
                            <span>Save Processed</span>
                            <div class="toggle-switch active" id="saveProcessedToggle"></div>
                        </div>
                        <div class="option-item">
                            <span>Compare Mode</span>
                            <div class="toggle-switch" id="compareToggle"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Column: Live Results & Clinical Data -->
            <div>
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">üìä Live Analysis Results</div>
                        <div class="status-badge live" id="liveStatus">
                            <span class="status-dot"></span>
                            <span>LIVE</span>
                        </div>
                    </div>

                    <div class="results-grid">
                        <div class="result-card" id="totalCellCard">
                            <div class="result-icon">üî¥</div>
                            <div class="result-label">Total Cells</div>
                            <div class="result-value" id="totalCount">0</div>
                            <div class="result-subtext">Current Frame</div>
                            <div class="result-change positive" id="totalChange">+0</div>
                        </div>
                        <div class="result-card" id="rbcCard">
                            <div class="result-icon">‚ö™</div>
                            <div class="result-label">Red Blood Cells</div>
                            <div class="result-value" id="rbcCount">0</div>
                            <div class="result-subtext">Erythrocytes</div>
                            <div class="result-change positive" id="rbcChange">+0</div>
                        </div>
                        <div class="result-card" id="wbcCard">
                            <div class="result-icon">üîµ</div>
                            <div class="result-label">White Blood Cells</div>
                            <div class="result-value" id="wbcCount">0</div>
                            <div class="result-subtext">Leukocytes</div>
                            <div class="result-change positive" id="wbcChange">+0</div>
                        </div>
                        <div class="result-card">
                            <div class="result-icon">‚ö°</div>
                            <div class="result-label">Processing Speed</div>
                            <div class="result-value" id="processingSpeed">0</div>
                            <div class="result-subtext">ms/frame</div>
                        </div>
                    </div>

                    <div class="clinical-metrics">
                        <div class="metric-item">
                            <div>
                                <div class="metric-label">RBC Density</div>
                                <div class="metric-range">Normal: 4.5-5.5 million/ŒºL</div>
                            </div>
                            <div style="text-align: right;">
                                <div class="metric-value" id="rbcDensity">0</div>
                                <div class="metric-status normal" id="rbcStatus">NORMAL</div>
                            </div>
                        </div>
                        <div class="metric-item">
                            <div>
                                <div class="metric-label">WBC Count</div>
                                <div class="metric-range">Normal: 4,000-11,000/ŒºL</div>
                            </div>
                            <div style="text-align: right;">
                                <div class="metric-value" id="wbcDensity">0</div>
                                <div class="metric-status normal" id="wbcStatus">NORMAL</div>
                            </div>
                        </div>
                        <div class="metric-item">
                            <div>
                                <div class="metric-label">Cell Viability</div>
                                <div class="metric-range">Target: >95%</div>
                            </div>
                            <div style="text-align: right;">
                                <div class="metric-value" id="viability">0%</div>
                                <div class="metric-status normal" id="viabilityStatus">NORMAL</div>
                            </div>
                        </div>
                    </div>

                    <div class="trial-info">
                        <div class="trial-header">ü©∫ ADVANCED PROCESSING DATA</div>
                        <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">
                            Active Filter: <span style="color: var(--clinical-purple); font-family: 'Orbitron', sans-serif;" id="activeFilter">None</span>
                        </div>
                        <div style="font-size: 12px; color: var(--text-muted);">
                            Processing Mode: <span style="color: var(--clinical-green);" id="processingMode">Live Camera</span>
                        </div>
                    </div>

                    <div class="data-export">
                        <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 8px;">
                            Export Data & Images:
                        </div>
                        <div class="export-buttons">
                            <button class="export-btn" onclick="exportCSV()">üìÑ CSV</button>
                            <button class="export-btn" onclick="exportJSON()">üìÅ JSON</button>
                            <button class="export-btn" onclick="exportPDF()">üìä PDF Report</button>
                            <button class="export-btn" onclick="saveProcessedImage()">üíæ Save Image</button>
                            <button class="export-btn" onclick="saveHistogram()">üìà Save Histogram</button>
                            <button class="export-btn" onclick="saveAllData()">üìö Export All</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card full-width" id="historyCard">
            <div class="card-header">
                <div class="card-title">üìà Analysis History & Filter Performance</div>
                <div class="setting-value" id="historyCount">0 readings</div>
            </div>
            <div id="historyChart" style="height: 200px; width: 100%; background: var(--dark-elevated); border-radius: 12px;"></div>
        </div>

        <footer>
            <p style="font-family: 'Orbitron', sans-serif;">HemaScan Pro Advanced ¬© 2024 | Advanced Processing Clinical System</p>
            <p style="margin-top: 12px; font-size: 11px;">IRB Approval: IRB-2024-HEMA-001 ‚Ä¢ Protocol Version: 4.0</p>
            <p style="margin-top: 8px; font-size: 10px; opacity: 0.6;">Advanced image processing with OpenCV ‚Ä¢ Real-time histogram analysis ‚Ä¢ Multi-format export</p>
        </footer>
    </div>

    <!-- Load OpenCV.js -->
    <script async src="https://docs.opencv.org/4.5.2/opencv.js" onload="onOpenCvReady()" type="text/javascript"></script>
    <!-- Load jsPDF library for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Load jsPDF AutoTable plugin -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>

    <script>
        // ========================================
        // GLOBAL VARIABLES
        // ========================================
        let video, canvas, ctx, processedCanvas, processedCtx;
        let originalCanvas, filterCanvas, histogramCanvas;
        let originalCtx, filterCtx, histogramCtx;
        let stream = null;
        let isOpenCvReady = false;
        let isLiveDetection = false;
        let liveInterval = null;
        let frameCount = 0;
        let lastFrameTime = 0;
        let fps = 0;
        let currentFilter = null;
        let uploadedImage = null;

        // Processing parameters
        let processingParams = {
            kernelSize: 3,
            sigma: 1.5,
            threshold1: 50,
            threshold2: 150,
            showHistogram: true,
            autoApply: false,
            saveProcessed: true,
            compareMode: false
        };

        // Clinical data storage
        let clinicalData = {
            trialId: "CT-2024-HEMA-001",
            patientId: "PAT-001-HEMA",
            patientInitials: "J.D.",
            patientAge: 45,
            patientGender: "Male",
            physician: "Dr. Sarah Chen, MD",
            institution: "Metropolitan Research Hospital",
            readings: [],
            currentReading: null,
            processingHistory: [],
            settings: {
                liveDetection: true,
                showMarkers: true,
                realtimeClassification: true,
                sensitivity: 75,
                analysisInterval: 500
            }
        };

        // Current frame results
        let currentResults = {
            total: 0,
            rbc: 0,
            wbc: 0,
            timestamp: 0,
            processingTime: 0,
            frameData: null,
            filterUsed: null,
            filterParams: null
        };

        // Previous results for comparison
        let previousResults = {
            total: 0,
            rbc: 0,
            wbc: 0
        };

        // DOM elements
        const statusText = document.getElementById('statusText');
        const cameraStatus = document.getElementById('cameraStatus');
        const videoOverlay = document.getElementById('videoOverlay');
        const startLiveBtn = document.getElementById('startLiveBtn');
        const stopLiveBtn = document.getElementById('stopLiveBtn');
        const captureBtn = document.getElementById('captureBtn');
        const resetBtn = document.getElementById('resetBtn');
        const analyzeUploadBtn = document.getElementById('analyzeUploadBtn');
        const liveStatus = document.getElementById('liveStatus');
        const fpsCounter = document.getElementById('fpsCounter');
        const opencvLoader = document.getElementById('opencvLoader');
        const fileInput = document.getElementById('fileInput');
        const imageUpload = document.getElementById('imageUpload');
        const imagePreview = document.getElementById('imagePreview');
        const activeFilter = document.getElementById('activeFilter');
        const processingMode = document.getElementById('processingMode');

        // ========================================
        // INITIALIZATION
        // ========================================
        async function init() {
            // Initialize canvas elements
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            processedCanvas = document.getElementById('processedCanvas');
            processedCtx = processedCanvas.getContext('2d');
            originalCanvas = document.getElementById('originalCanvas');
            originalCtx = originalCanvas.getContext('2d');
            filterCanvas = document.getElementById('filterCanvas');
            filterCtx = filterCanvas.getContext('2d');
            histogramCanvas = document.getElementById('histogramCanvas');
            histogramCtx = histogramCanvas.getContext('2d');

            // Set canvas dimensions
            originalCanvas.width = filterCanvas.width = 400;
            originalCanvas.height = filterCanvas.height = 300;
            histogramCanvas.width = 600;
            histogramCanvas.height = 180;

            // Wait for OpenCV
            await waitForOpenCV();

            // Initialize camera
            await initCamera();

            // Set up event listeners
            setupEventListeners();

            // Initialize chart
            initHistoryChart();

            // Start FPS counter
            startFPSCounter();

            // Initialize histogram
            drawEmptyHistogram();
        }

        function setupEventListeners() {
            // Main controls
            startLiveBtn.addEventListener('click', startLiveDetection);
            stopLiveBtn.addEventListener('click', stopLiveDetection);
            captureBtn.addEventListener('click', captureSnapshot);
            resetBtn.addEventListener('click', resetClinicalData);
            analyzeUploadBtn.addEventListener('click', analyzeUploadedImage);

            // Tab switching
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const tab = this.dataset.tab;
                    
                    // Update tabs
                    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Update tab content
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
                    document.getElementById(tab + 'Tab').classList.remove('hidden');
                    
                    // Update processing mode
                    processingMode.textContent = tab === 'camera' ? 'Live Camera' : 
                                                tab === 'upload' ? 'Image Upload' : 
                                                'Processed View';
                });
            });

            // Image upload
            imageUpload.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleImageUpload);

            // Filter buttons
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const filter = this.dataset.filter;
                    
                    // Update active filter
                    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Apply filter
                    currentFilter = filter;
                    activeFilter.textContent = filter.charAt(0).toUpperCase() + filter.slice(1);
                    
                    if (processingParams.autoApply) {
                        applyCurrentFilter();
                    }
                });
            });

            // Processing controls
            document.getElementById('kernelSlider').addEventListener('input', function() {
                processingParams.kernelSize = parseInt(this.value);
                document.getElementById('kernelValue').textContent = this.value;
                if (processingParams.autoApply) applyCurrentFilter();
            });

            document.getElementById('sigmaSlider').addEventListener('input', function() {
                processingParams.sigma = parseFloat(this.value);
                document.getElementById('sigmaValue').textContent = this.value;
                if (processingParams.autoApply) applyCurrentFilter();
            });

            document.getElementById('threshold1Slider').addEventListener('input', function() {
                processingParams.threshold1 = parseInt(this.value);
                document.getElementById('threshold1Value').textContent = this.value;
                if (processingParams.autoApply) applyCurrentFilter();
            });

            document.getElementById('threshold2Slider').addEventListener('input', function() {
                processingParams.threshold2 = parseInt(this.value);
                document.getElementById('threshold2Value').textContent = this.value;
                if (processingParams.autoApply) applyCurrentFilter();
            });

            // Toggle switches
            document.getElementById('histogramToggle').addEventListener('click', function() {
                this.classList.toggle('active');
                processingParams.showHistogram = this.classList.contains('active');
                if (processingParams.showHistogram) {
                    drawHistogram();
                } else {
                    drawEmptyHistogram();
                }
            });

            document.getElementById('autoApplyToggle').addEventListener('click', function() {
                this.classList.toggle('active');
                processingParams.autoApply = this.classList.contains('active');
            });

            document.getElementById('saveProcessedToggle').addEventListener('click', function() {
                this.classList.toggle('active');
                processingParams.saveProcessed = this.classList.contains('active');
            });

            document.getElementById('compareToggle').addEventListener('click', function() {
                this.classList.toggle('active');
                processingParams.compareMode = this.classList.contains('active');
                updateDisplayMode();
            });

            // Settings toggles (from original)
            document.getElementById('liveToggle').addEventListener('click', function() {
                this.classList.toggle('active');
                clinicalData.settings.liveDetection = this.classList.contains('active');
                if (clinicalData.settings.liveDetection && !isLiveDetection) {
                    startLiveDetection();
                } else if (!clinicalData.settings.liveDetection && isLiveDetection) {
                    stopLiveDetection();
                }
            });

            document.getElementById('markerToggle').addEventListener('click', function() {
                this.classList.toggle('active');
                clinicalData.settings.showMarkers = this.classList.contains('active');
            });

            document.getElementById('classificationToggle').addEventListener('click', function() {
                this.classList.toggle('active');
                clinicalData.settings.realtimeClassification = this.classList.contains('active');
            });

            // Sliders (from original)
            document.getElementById('sensitivitySlider').addEventListener('input', function() {
                clinicalData.settings.sensitivity = parseInt(this.value);
                document.getElementById('sensitivityValue').textContent = this.value + '%';
            });

            document.getElementById('intervalSlider').addEventListener('input', function() {
                clinicalData.settings.analysisInterval = parseInt(this.value);
                document.getElementById('intervalValue').textContent = this.value + 'ms';
                
                if (isLiveDetection) {
                    stopLiveDetection();
                    setTimeout(startLiveDetection, 100);
                }
            });
        }

        // ========================================
        // OPENCV INITIALIZATION
        // ========================================
        function waitForOpenCV() {
            return new Promise((resolve) => {
                const progressFill = document.querySelector('.progress-fill');
                let progress = 0;
                
                const checkOpenCV = setInterval(() => {
                    progress = Math.min(progress + 5, 95);
                    progressFill.style.width = progress + '%';
                    
                    if (typeof cv !== 'undefined') {
                        clearInterval(checkOpenCV);
                        progressFill.style.width = '100%';
                        setTimeout(() => {
                            isOpenCvReady = true;
                            opencvLoader.style.display = 'none';
                            resolve();
                        }, 300);
                    }
                }, 100);
            });
        }

        function onOpenCvReady() {
            isOpenCvReady = true;
            console.log('OpenCV.js ready for advanced processing');
        }

        // ========================================
        // CAMERA INITIALIZATION
        // ========================================
        async function initCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        frameRate: { ideal: 30 }
                    },
                    audio: false
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;

                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    processedCanvas.width = video.videoWidth;
                    processedCanvas.height = video.videoHeight;

                    videoOverlay.classList.add('hidden');
                    captureBtn.disabled = false;
                    
                    updateCameraStatus('ready', 'Ready for Live Detection');
                };
            } catch (error) {
                console.error('Camera error:', error);
                updateCameraStatus('error', 'Camera Error');
                alert('Unable to access camera. Please grant permissions and reload.');
            }
        }

        function updateCameraStatus(status, text) {
            cameraStatus.className = `status-badge ${status}`;
            statusText.textContent = text;
        }

        // ========================================
        // IMAGE UPLOAD HANDLING
        // ========================================
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    uploadedImage = img;
                    imagePreview.src = e.target.result;
                    imagePreview.style.display = 'block';
                    
                    // Set canvas dimensions to match image
                    originalCanvas.width = filterCanvas.width = img.width > 400 ? 400 : img.width;
                    originalCanvas.height = filterCanvas.height = img.height > 300 ? 300 : img.height;
                    
                    // Draw original image
                    originalCtx.drawImage(img, 0, 0, originalCanvas.width, originalCanvas.height);
                    
                    alert('Image uploaded successfully! Click "Analyze Image" to process.');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        async function analyzeUploadedImage() {
            if (!uploadedImage) {
                alert('Please upload an image first.');
                return;
            }

            // Switch to processed view
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
            document.querySelector('[data-tab="processed"]').classList.add('active');
            document.getElementById('processedTab').classList.remove('hidden');
            processingMode.textContent = 'Image Analysis';

            // Process the uploaded image
            await processImage(uploadedImage);
        }

        // ========================================
        // ADVANCED IMAGE PROCESSING FILTERS
        // ========================================
        async function processImage(image) {
            try {
                // Create a temporary canvas for processing
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = image.width;
                tempCanvas.height = image.height;
                tempCtx.drawImage(image, 0, 0);

                // Get image data
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                let src = cv.matFromImageData(imageData);

                // Store original for comparison
                const originalMat = src.clone();

                // Apply current filter if selected
                if (currentFilter) {
                    src = await applyFilter(src, currentFilter);
                }

                // Draw processed image
                cv.imshow(filterCanvas, src);
                cv.imshow(originalCanvas, originalMat);

                // Detect cells on processed image
                const detected = await detectCellsAdvanced(src);
                updateResultsFromDetection(detected);

                // Draw histogram
                if (processingParams.showHistogram) {
                    drawHistogramFromMat(src);
                }

                // Store processing history
                storeProcessingHistory(currentFilter, detected);

                // Cleanup
                src.delete();
                originalMat.delete();

            } catch (error) {
                console.error('Image processing error:', error);
                alert('Error processing image: ' + error.message);
            }
        }

        async function applyFilter(src, filterType) {
            let dst = new cv.Mat();
            
            try {
                switch (filterType) {
                    case 'gaussian':
                        const ksize = new cv.Size(processingParams.kernelSize, processingParams.kernelSize);
                        cv.GaussianBlur(src, dst, ksize, processingParams.sigma, 0, cv.BORDER_DEFAULT);
                        break;

                    case 'median':
                        cv.medianBlur(src, dst, processingParams.kernelSize);
                        break;

                    case 'bilateral':
                        cv.bilateralFilter(src, dst, processingParams.kernelSize, processingParams.sigma * 2, processingParams.sigma);
                        break;

                    case 'contrast':
                        // Contrast enhancement using CLAHE
                        const lab = new cv.Mat();
                        cv.cvtColor(src, lab, cv.COLOR_RGBA2Lab);
                        
                        const labPlanes = new cv.MatVector();
                        cv.split(lab, labPlanes);
                        
                        const clahe = new cv.CLAHE();
                        clahe.setClipLimit(2.0);
                        clahe.setTilesGridSize(new cv.Size(8, 8));
                        
                        const dstPlane = new cv.Mat();
                        clahe.apply(labPlanes.get(0), dstPlane);
                        
                        dstPlane.copyTo(labPlanes.get(0));
                        cv.merge(labPlanes, lab);
                        cv.cvtColor(lab, dst, cv.COLOR_Lab2RGBA);
                        
                        lab.delete();
                        labPlanes.delete();
                        dstPlane.delete();
                        clahe.delete();
                        break;

                    case 'colorspace':
                        // Convert to HSV color space
                        cv.cvtColor(src, dst, cv.COLOR_RGBA2HSV);
                        break;

                    case 'segmentation':
                        // Simple threshold segmentation
                        const gray = new cv.Mat();
                        cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                        cv.threshold(gray, dst, processingParams.threshold1, processingParams.threshold2, cv.THRESH_BINARY);
                        gray.delete();
                        break;

                    case 'canny':
                        const gray2 = new cv.Mat();
                        cv.cvtColor(src, gray2, cv.COLOR_RGBA2GRAY);
                        cv.Canny(gray2, dst, processingParams.threshold1, processingParams.threshold2);
                        gray2.delete();
                        break;

                    case 'morphology':
                        // Morphological operations
                        const gray3 = new cv.Mat();
                        cv.cvtColor(src, gray3, cv.COLOR_RGBA2GRAY);
                        const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, 
                            new cv.Size(processingParams.kernelSize, processingParams.kernelSize));
                        cv.morphologyEx(gray3, dst, cv.MORPH_OPEN, kernel);
                        gray3.delete();
                        kernel.delete();
                        break;

                    case 'adaptive':
                        // Adaptive threshold
                        const gray4 = new cv.Mat();
                        cv.cvtColor(src, gray4, cv.COLOR_RGBA2GRAY);
                        cv.adaptiveThreshold(gray4, dst, 255, 
                            cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 
                            11, 2);
                        gray4.delete();
                        break;

                    default:
                        dst = src.clone();
                        break;
                }
            } catch (error) {
                console.error('Filter application error:', error);
                dst = src.clone();
            }

            return dst;
        }

        async function applyCurrentFilter() {
            if (!currentFilter) return;

            // Get current frame
            if (uploadedImage) {
                await processImage(uploadedImage);
            } else if (isLiveDetection) {
                // Apply filter to live frame
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const src = cv.matFromImageData(imageData);
                
                try {
                    const processed = await applyFilter(src, currentFilter);
                    cv.imshow(processedCanvas, processed);
                    
                    // Show processed canvas
                    processedCanvas.classList.remove('hidden');
                    
                    // Detect cells on processed image
                    const detected = await detectCellsAdvanced(processed);
                    updateResultsFromDetection(detected);
                    
                    // Draw histogram
                    if (processingParams.showHistogram) {
                        drawHistogramFromMat(processed);
                    }
                    
                    processed.delete();
                } catch (error) {
                    console.error('Live filter error:', error);
                } finally {
                    src.delete();
                }
            }
        }

        // ========================================
        // ADVANCED CELL DETECTION
        // ========================================
        async function detectCellsAdvanced(src) {
            const contours = new cv.MatVector();
            const hierarchy = new cv.Mat();
            
            try {
                // Convert to grayscale for processing
                const gray = new cv.Mat();
                if (src.channels() === 4) {
                    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                } else if (src.channels() === 3) {
                    cv.cvtColor(src, gray, cv.COLOR_RGB2GRAY);
                } else {
                    gray = src.clone();
                }

                // Apply adaptive threshold
                const thresh = new cv.Mat();
                cv.adaptiveThreshold(gray, thresh, 255, 
                    cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 
                    11, 2);

                // Find contours
                cv.findContours(thresh, contours, hierarchy, 
                    cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                const sensitivity = clinicalData.settings.sensitivity / 100;
                const minArea = 30 * sensitivity;
                const maxArea = 5000;

                let total = 0;
                let rbc = 0;
                let wbc = 0;
                const cells = [];

                for (let i = 0; i < contours.size(); i++) {
                    const contour = contours.get(i);
                    const area = cv.contourArea(contour);

                    if (area > minArea && area < maxArea) {
                        total++;
                        
                        // Advanced classification based on shape features
                        const perimeter = cv.arcLength(contour, true);
                        const circularity = (4 * Math.PI * area) / (perimeter * perimeter);
                        
                        if (area < 300 && circularity > 0.7) {
                            rbc++; // Round RBCs
                        } else if (area < 800 && circularity > 0.5) {
                            wbc++; // Larger, less circular WBCs
                        } else if (area >= 800) {
                            wbc++; // Very large cells (likely WBCs)
                        }

                        // Store cell data
                        const moments = cv.moments(contour);
                        if (moments.m00 !== 0) {
                            cells.push({
                                x: moments.m10 / moments.m00,
                                y: moments.m01 / moments.m00,
                                radius: Math.sqrt(area / Math.PI),
                                area: area,
                                circularity: circularity,
                                type: area < 300 && circularity > 0.7 ? 'RBC' : 'WBC'
                            });
                        }
                    }
                }

                // Cleanup
                gray.delete();
                thresh.delete();

                return {
                    total,
                    rbc,
                    wbc,
                    cells,
                    contours: contours.size()
                };

            } catch (error) {
                console.error('Advanced detection error:', error);
                return { total: 0, rbc: 0, wbc: 0, cells: [], contours: 0 };
            } finally {
                contours.delete();
                hierarchy.delete();
            }
        }

        // ========================================
        // HISTOGRAM FUNCTIONS
        // ========================================
        function drawHistogramFromMat(mat) {
            if (mat.channels() === 1) {
                drawGrayscaleHistogram(mat);
            } else if (mat.channels() === 3 || mat.channels() === 4) {
                drawColorHistogram(mat);
            }
        }

        function drawGrayscaleHistogram(mat) {
            const width = histogramCanvas.width;
            const height = histogramCanvas.height;
            
            // Clear histogram
            histogramCtx.clearRect(0, 0, width, height);
            
            // Calculate histogram
            const histogram = new Array(256).fill(0);
            const data = mat.data;
            
            for (let i = 0; i < data.length; i += mat.channels()) {
                const value = mat.channels() === 1 ? data[i] : 
                             Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                histogram[value]++;
            }
            
            // Find max frequency
            const maxFreq = Math.max(...histogram);
            
            // Draw histogram
            histogramCtx.fillStyle = 'rgba(76, 175, 80, 0.1)';
            histogramCtx.fillRect(0, 0, width, height);
            
            histogramCtx.strokeStyle = '#4CAF50';
            histogramCtx.lineWidth = 2;
            histogramCtx.beginPath();
            
            const binWidth = width / 256;
            
            for (let i = 0; i < 256; i++) {
                const x = i * binWidth;
                const barHeight = (histogram[i] / maxFreq) * height * 0.8;
                const y = height - barHeight;
                
                if (i === 0) {
                    histogramCtx.moveTo(x, y);
                } else {
                    histogramCtx.lineTo(x, y);
                }
            }
            
            histogramCtx.stroke();
            
            // Draw labels
            histogramCtx.fillStyle = '#ffffff';
            histogramCtx.font = '10px Arial';
            histogramCtx.textAlign = 'center';
            histogramCtx.fillText('Intensity (0-255)', width / 2, height - 5);
            histogramCtx.save();
            histogramCtx.translate(10, height / 2);
            histogramCtx.rotate(-Math.PI / 2);
            histogramCtx.fillText('Frequency', 0, 0);
            histogramCtx.restore();
            
            // Draw statistics
            const mean = histogram.reduce((sum, freq, i) => sum + i * freq, 0) / data.length * mat.channels();
            const stdDev = Math.sqrt(histogram.reduce((sum, freq, i) => sum + Math.pow(i - mean, 2) * freq, 0) / data.length * mat.channels());
            
            histogramCtx.fillStyle = '#2196F3';
            histogramCtx.font = '12px Arial';
            histogramCtx.textAlign = 'left';
            histogramCtx.fillText(`Mean: ${mean.toFixed(1)}`, 10, 20);
            histogramCtx.fillText(`Std Dev: ${stdDev.toFixed(1)}`, 10, 40);
        }

        function drawColorHistogram(mat) {
            const width = histogramCanvas.width;
            const height = histogramCanvas.height;
            
            // Clear histogram
            histogramCtx.clearRect(0, 0, width, height);
            
            // Calculate histograms for each channel
            const histR = new Array(256).fill(0);
            const histG = new Array(256).fill(0);
            const histB = new Array(256).fill(0);
            
            const data = mat.data;
            const channels = mat.channels();
            
            for (let i = 0; i < data.length; i += channels) {
                histR[data[i]]++;
                histG[data[i + 1]]++;
                histB[data[i + 2]]++;
            }
            
            // Find max frequency
            const maxFreq = Math.max(...histR, ...histG, ...histB);
            
            // Draw grid
            histogramCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            histogramCtx.fillRect(0, 0, width, height);
            
            // Draw histograms
            const binWidth = width / 256;
            
            // Red channel
            histogramCtx.strokeStyle = '#ff4444';
            histogramCtx.lineWidth = 1;
            histogramCtx.beginPath();
            for (let i = 0; i < 256; i++) {
                const x = i * binWidth;
                const barHeight = (histR[i] / maxFreq) * height * 0.8;
                const y = height - barHeight;
                
                if (i === 0) {
                    histogramCtx.moveTo(x, y);
                } else {
                    histogramCtx.lineTo(x, y);
                }
            }
            histogramCtx.stroke();
            
            // Green channel
            histogramCtx.strokeStyle = '#44ff44';
            histogramCtx.beginPath();
            for (let i = 0; i < 256; i++) {
                const x = i * binWidth;
                const barHeight = (histG[i] / maxFreq) * height * 0.8;
                const y = height - barHeight;
                
                if (i === 0) {
                    histogramCtx.moveTo(x, y);
                } else {
                    histogramCtx.lineTo(x, y);
                }
            }
            histogramCtx.stroke();
            
            // Blue channel
            histogramCtx.strokeStyle = '#4444ff';
            histogramCtx.beginPath();
            for (let i = 0; i < 256; i++) {
                const x = i * binWidth;
                const barHeight = (histB[i] / maxFreq) * height * 0.8;
                const y = height - barHeight;
                
                if (i === 0) {
                    histogramCtx.moveTo(x, y);
                } else {
                    histogramCtx.lineTo(x, y);
                }
            }
            histogramCtx.stroke();
            
            // Draw labels
            histogramCtx.fillStyle = '#ffffff';
            histogramCtx.font = '10px Arial';
            histogramCtx.textAlign = 'center';
            histogramCtx.fillText('Intensity (0-255)', width / 2, height - 5);
            
            // Draw legend
            histogramCtx.fillStyle = '#ff4444';
            histogramCtx.fillRect(width - 120, 10, 10, 10);
            histogramCtx.fillStyle = '#44ff44';
            histogramCtx.fillRect(width - 120, 25, 10, 10);
            histogramCtx.fillStyle = '#4444ff';
            histogramCtx.fillRect(width - 120, 40, 10, 10);
            
            histogramCtx.fillStyle = '#ffffff';
            histogramCtx.font = '10px Arial';
            histogramCtx.textAlign = 'left';
            histogramCtx.fillText('Red Channel', width - 105, 18);
            histogramCtx.fillText('Green Channel', width - 105, 33);
            histogramCtx.fillText('Blue Channel', width - 105, 48);
        }

        function drawEmptyHistogram() {
            const width = histogramCanvas.width;
            const height = histogramCanvas.height;
            
            histogramCtx.clearRect(0, 0, width, height);
            histogramCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            histogramCtx.fillRect(0, 0, width, height);
            
            histogramCtx.fillStyle = '#666666';
            histogramCtx.font = '16px Arial';
            histogramCtx.textAlign = 'center';
            histogramCtx.textBaseline = 'middle';
            histogramCtx.fillText('Histogram will appear here', width / 2, height / 2);
        }

        function drawHistogram() {
            if (!uploadedImage && !isLiveDetection) {
                drawEmptyHistogram();
                return;
            }
            
            // Get current image data based on mode
            if (uploadedImage) {
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = uploadedImage.width;
                tempCanvas.height = uploadedImage.height;
                tempCtx.drawImage(uploadedImage, 0, 0);
                const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                const src = cv.matFromImageData(imageData);
                drawHistogramFromMat(src);
                src.delete();
            }
        }

        // ========================================
        // LIVE DETECTION (UPDATED WITH FILTERS)
        // ========================================
        async function startLiveDetection() {
            if (isLiveDetection || !isOpenCvReady) return;

            isLiveDetection = true;
            startLiveBtn.classList.add('hidden');
            stopLiveBtn.classList.remove('hidden');
            liveStatus.classList.add('live');

            // Clear previous interval
            if (liveInterval) clearInterval(liveInterval);

            // Start live detection loop
            liveInterval = setInterval(async () => {
                if (!video.videoWidth || !video.videoHeight) return;

                const startTime = performance.now();

                try {
                    // Process current frame with optional filter
                    await processLiveFrame();

                    // Update processing speed
                    currentResults.processingTime = Math.round(performance.now() - startTime);
                    updateProcessingSpeed();

                } catch (error) {
                    console.error('Frame processing error:', error);
                }
            }, clinicalData.settings.analysisInterval);
        }

        async function processLiveFrame() {
            if (!video.videoWidth || !video.videoHeight) return;

            // Draw video frame to canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Get image data for processing
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const src = cv.matFromImageData(imageData);

            try {
                // Apply current filter if selected
                let processed = src;
                if (currentFilter && processingParams.autoApply) {
                    processed = await applyFilter(src, currentFilter);
                    cv.imshow(processedCanvas, processed);
                    processedCanvas.classList.remove('hidden');
                }

                // Detect cells
                const detected = await detectCellsAdvanced(processed);

                // Update current results
                previousResults = { ...currentResults };
                currentResults = {
                    total: detected.total || 0,
                    rbc: detected.rbc || 0,
                    wbc: detected.wbc || 0,
                    timestamp: Date.now(),
                    processingTime: 0,
                    frameData: imageData,
                    filterUsed: currentFilter,
                    filterParams: { ...processingParams }
                };

                // Draw markers if enabled
                if (clinicalData.settings.showMarkers && detected.cells) {
                    drawLiveMarkers(detected.cells);
                }

                // Update UI with new results
                updateLiveResults();

                // Store reading for clinical data
                storeClinicalReading();

                // Store processing history
                storeProcessingHistory(currentFilter, detected);

                // Update histogram
                if (processingParams.showHistogram) {
                    drawHistogramFromMat(processed);
                }

                // Clean up
                if (processed !== src) {
                    processed.delete();
                }

            } catch (error) {
                console.error('Live frame processing error:', error);
            } finally {
                src.delete();
            }
        }

        function drawLiveMarkers(cells) {
            // Clear previous markers
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            // Draw each cell marker
            cells.forEach((cell, index) => {
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, cell.radius + 3, 0, 2 * Math.PI);
                ctx.strokeStyle = cell.type === 'RBC' ? '#4CAF50' : '#2196F3';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Center dot
                ctx.beginPath();
                ctx.arc(cell.x, cell.y, 2, 0, 2 * Math.PI);
                ctx.fillStyle = '#ffffff';
                ctx.fill();

                // Cell ID
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px Arial';
                ctx.fillText(index + 1, cell.x - 3, cell.y - 10);
            });
        }

        // ========================================
        // RESULTS MANAGEMENT
        // ========================================
        function updateResultsFromDetection(detected) {
            previousResults = { ...currentResults };
            currentResults = {
                total: detected.total || 0,
                rbc: detected.rbc || 0,
                wbc: detected.wbc || 0,
                timestamp: Date.now(),
                processingTime: 0,
                frameData: null,
                filterUsed: currentFilter,
                filterParams: { ...processingParams }
            };

            updateLiveResults();
            storeClinicalReading();
        }

        function updateLiveResults() {
            // Update counts with animation
            updateCount('totalCount', currentResults.total);
            updateCount('rbcCount', currentResults.rbc);
            updateCount('wbcCount', currentResults.wbc);

            // Update changes
            updateChange('totalChange', currentResults.total - previousResults.total);
            updateChange('rbcChange', currentResults.rbc - previousResults.rbc);
            updateChange('wbcChange', currentResults.wbc - previousResults.wbc);

            // Update clinical metrics
            updateClinicalMetrics();

            // Update processing speed
            document.getElementById('processingSpeed').textContent = currentResults.processingTime;
        }

        function updateCount(elementId, value) {
            const element = document.getElementById(elementId);
            const current = parseInt(element.textContent) || 0;
            
            if (current !== value) {
                element.textContent = value;
                element.parentElement.classList.add('live-update');
                setTimeout(() => {
                    element.parentElement.classList.remove('live-update');
                }, 500);
            }
        }

        function updateChange(elementId, change) {
            const element = document.getElementById(elementId);
            if (change > 0) {
                element.textContent = `+${change}`;
                element.className = 'result-change positive';
            } else if (change < 0) {
                element.textContent = `${change}`;
                element.className = 'result-change negative';
            } else {
                element.textContent = '¬±0';
                element.className = 'result-change';
            }
        }

        function updateClinicalMetrics() {
            // Calculate RBC density (simulated conversion)
            const rbcDensity = Math.round(currentResults.rbc * 1000);
            document.getElementById('rbcDensity').textContent = `${(rbcDensity / 1000000).toFixed(2)}M`;
            
            // Update RBC status
            const rbcStatus = document.getElementById('rbcStatus');
            if (rbcDensity > 5500000) {
                rbcStatus.textContent = 'HIGH';
                rbcStatus.className = 'metric-status warning';
            } else if (rbcDensity < 4500000) {
                rbcStatus.textContent = 'LOW';
                rbcStatus.className = 'metric-status warning';
            } else {
                rbcStatus.textContent = 'NORMAL';
                rbcStatus.className = 'metric-status normal';
            }

            // Calculate WBC density
            const wbcDensity = Math.round(currentResults.wbc * 100);
            document.getElementById('wbcDensity').textContent = wbcDensity.toLocaleString();
            
            // Update WBC status
            const wbcStatus = document.getElementById('wbcStatus');
            if (wbcDensity > 11000) {
                wbcStatus.textContent = 'HIGH';
                wbcStatus.className = 'metric-status warning';
            } else if (wbcDensity < 4000) {
                wbcStatus.textContent = 'LOW';
                wbcStatus.className = 'metric-status warning';
            } else {
                wbcStatus.textContent = 'NORMAL';
                wbcStatus.className = 'metric-status normal';
            }

            // Calculate viability (simulated)
            const viability = Math.min(100, Math.round((currentResults.total / Math.max(1, previousResults.total)) * 100));
            document.getElementById('viability').textContent = `${viability}%`;
            
            // Update viability status
            const viabilityStatus = document.getElementById('viabilityStatus');
            if (viability > 95) {
                viabilityStatus.textContent = 'EXCELLENT';
                viabilityStatus.className = 'metric-status normal';
            } else if (viability > 85) {
                viabilityStatus.textContent = 'GOOD';
                viabilityStatus.className = 'metric-status normal';
            } else {
                viabilityStatus.textContent = 'POOR';
                viabilityStatus.className = 'metric-status warning';
            }
        }

        function updateProcessingSpeed() {
            document.getElementById('processingSpeed').textContent = currentResults.processingTime;
        }

        function updateDisplayMode() {
            if (processingParams.compareMode) {
                originalCanvas.parentElement.parentElement.style.display = 'grid';
            } else {
                originalCanvas.parentElement.parentElement.style.display = 'block';
                filterCanvas.parentElement.style.gridColumn = '1 / -1';
            }
        }

        // ========================================
        // DATA STORAGE & HISTORY
        // ========================================
        function storeClinicalReading() {
            const reading = {
                timestamp: new Date().toISOString(),
                totalCells: currentResults.total,
                rbcCount: currentResults.rbc,
                wbcCount: currentResults.wbc,
                processingTime: currentResults.processingTime,
                filterUsed: currentResults.filterUsed,
                filterParams: currentResults.filterParams,
                settings: { ...clinicalData.settings }
            };

            clinicalData.readings.push(reading);
            clinicalData.currentReading = reading;

            // Update history count
            document.getElementById('historyCount').textContent = `${clinicalData.readings.length} readings`;

            // Update history chart
            updateHistoryChart();
        }

        function storeProcessingHistory(filter, detection) {
            const history = {
                timestamp: new Date().toISOString(),
                filter: filter,
                totalCells: detection.total,
                rbcCount: detection.rbc,
                wbcCount: detection.wbc,
                contours: detection.contours,
                params: { ...processingParams }
            };

            clinicalData.processingHistory.push(history);
        }

        // ========================================
        // HISTORY CHART
        // ========================================
        function initHistoryChart() {
            // Simple chart implementation
            const chartContainer = document.getElementById('historyChart');
            
            // Create canvas for chart
            const chartCanvas = document.createElement('canvas');
            chartCanvas.width = chartContainer.clientWidth;
            chartCanvas.height = chartContainer.clientHeight;
            chartContainer.appendChild(chartCanvas);
        }

        function updateHistoryChart() {
            const chartContainer = document.getElementById('historyChart');
            const ctx = chartContainer.querySelector('canvas').getContext('2d');
            
            // Clear chart
            ctx.clearRect(0, 0, chartContainer.clientWidth, chartContainer.clientHeight);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(76, 175, 80, 0.1)';
            ctx.lineWidth = 1;
            
            // Draw data points
            if (clinicalData.readings.length > 0) {
                const maxDataPoints = 50;
                const startIndex = Math.max(0, clinicalData.readings.length - maxDataPoints);
                const readings = clinicalData.readings.slice(startIndex);
                
                // Draw RBC line
                ctx.beginPath();
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                
                readings.forEach((reading, index) => {
                    const x = (index / (readings.length - 1)) * chartContainer.clientWidth;
                    const y = chartContainer.clientHeight - (reading.rbcCount / Math.max(...readings.map(r => r.rbcCount || 1))) * chartContainer.clientHeight * 0.8;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Draw WBC line
                ctx.beginPath();
                ctx.strokeStyle = '#2196F3';
                ctx.lineWidth = 2;
                
                readings.forEach((reading, index) => {
                    const x = (index / (readings.length - 1)) * chartContainer.clientWidth;
                    const y = chartContainer.clientHeight - (reading.wbcCount / Math.max(...readings.map(r => r.wbcCount || 1))) * chartContainer.clientHeight * 0.8;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }
        }

        // ========================================
        // SAVE & EXPORT FUNCTIONS
        // ========================================
        function saveProcessedImage() {
            if (!uploadedImage && !isLiveDetection) {
                alert('No image to save. Please start live detection or upload an image.');
                return;
            }

            const canvasToSave = filterCanvas;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filterName = currentFilter ? currentFilter : 'original';
            
            const link = document.createElement('a');
            link.download = `hema-pro-${filterName}-${timestamp}.png`;
            link.href = canvasToSave.toDataURL('image/png');
            link.click();
            
            alert(`Processed image saved as ${link.download}`);
        }

        function saveHistogram() {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const link = document.createElement('a');
            link.download = `histogram-${timestamp}.png`;
            link.href = histogramCanvas.toDataURL('image/png');
            link.click();
        }

        function saveAllData() {
            // Save processed image
            saveProcessedImage();
            
            // Save histogram
            setTimeout(saveHistogram, 500);
            
            // Save clinical data
            setTimeout(exportClinicalData, 1000);
            
            alert('All data export started. Check your downloads folder.');
        }

        function exportClinicalData() {
            const dataStr = JSON.stringify(clinicalData, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `clinical-data-${clinicalData.trialId}-${new Date().toISOString().slice(0,10)}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
        }

        function exportCSV() {
            if (clinicalData.readings.length === 0) {
                alert('No data to export');
                return;
            }

            let csv = 'Timestamp,Total Cells,RBC Count,WBC Count,Processing Time(ms),Filter Used\n';
            
            clinicalData.readings.forEach(reading => {
                csv += `${reading.timestamp},${reading.totalCells},${reading.rbcCount},${reading.wbcCount},${reading.processingTime},${reading.filterUsed || 'None'}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `clinical-data-${clinicalData.trialId}.csv`;
            a.click();
        }

        function exportJSON() {
            exportClinicalData();
        }

        // ========================================
        // PDF REPORT GENERATION (UPDATED)
        // ========================================
        async function exportPDF() {
            if (clinicalData.readings.length === 0) {
                alert('No clinical data available for PDF report. Please run some analysis first.');
                return;
            }

            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'portrait',
                    unit: 'mm',
                    format: 'a4'
                });

                doc.setProperties({
                    title: `Advanced Blood Analysis Report - ${clinicalData.trialId}`,
                    subject: 'HemaScan Pro Advanced Analysis',
                    author: 'HemaScan Pro Advanced System',
                    keywords: 'hematology, image processing, blood analysis, clinical trial',
                    creator: 'HemaScan Pro Advanced v4.0'
                });

                // Title Page
                createAdvancedTitlePage(doc);

                // Patient Information
                doc.addPage();
                createPatientInfoPage(doc);

                // Analysis Results with Filters
                doc.addPage();
                createAdvancedAnalysisPage(doc);

                // Image Processing Details
                doc.addPage();
                createImageProcessingPage(doc);

                // Technical Details
                doc.addPage();
                createTechnicalPage(doc);

                const timestamp = new Date().toISOString().slice(0, 19).replace(/[:]/g, '-');
                doc.save(`HemaScan_Pro_Report_${clinicalData.trialId}_${timestamp}.pdf`);
                
            } catch (error) {
                console.error('PDF generation error:', error);
                alert('Error generating PDF report. Please try again.');
            }
        }

        function createAdvancedTitlePage(doc) {
            doc.setFillColor(76, 175, 80);
            doc.rect(0, 0, 210, 40, 'F');
            
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(24);
            doc.setFont('helvetica', 'bold');
            doc.text('ADVANCED HEMATOLOGY ANALYSIS REPORT', 105, 20, { align: 'center' });
            
            doc.setFontSize(12);
            doc.text('HemaScan Pro Advanced with Image Processing', 105, 28, { align: 'center' });
            
            // Logo
            doc.setFillColor(156, 39, 176);
            doc.circle(105, 70, 15, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(20);
            doc.text('HP', 105, 74, { align: 'center' });
            
            // Report title
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(18);
            doc.setFont('helvetica', 'bold');
            doc.text('IMAGE PROCESSING & CELL ANALYSIS', 105, 110, { align: 'center' });
            
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text('Advanced Filter Analysis Report', 105, 120, { align: 'center' });
            
            // Report details
            const currentDate = new Date().toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            
            doc.setFontSize(10);
            doc.text(`Report Date: ${currentDate}`, 20, 140);
            doc.text(`Trial ID: ${clinicalData.trialId}`, 20, 147);
            doc.text(`Patient ID: ${clinicalData.patientId}`, 20, 154);
            doc.text(`Processing Mode: ${processingMode.textContent}`, 20, 161);
            doc.text(`Active Filter: ${activeFilter.textContent}`, 20, 168);
            
            // Confidentiality notice
            doc.setFontSize(8);
            doc.setTextColor(100, 100, 100);
            doc.text('ADVANCED PROCESSING - For Clinical Research Only', 105, 280, { align: 'center' });
            doc.text('IRB Approval: IRB-2024-HEMA-001 ‚Ä¢ Protocol Version: 4.0', 105, 285, { align: 'center' });
        }

        function createPatientInfoPage(doc) {
            doc.setFillColor(33, 150, 243);
            doc.rect(0, 0, 210, 15, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('PATIENT INFORMATION & PROCESSING SUMMARY', 105, 10, { align: 'center' });
            
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(10);
            
            doc.autoTable({
                startY: 25,
                head: [['Patient Information', '']],
                body: [
                    ['Patient ID', clinicalData.patientId],
                    ['Patient Initials', clinicalData.patientInitials],
                    ['Age', clinicalData.patientAge],
                    ['Gender', clinicalData.patientGender],
                    ['Physician', clinicalData.physician],
                    ['Institution', clinicalData.institution],
                    ['Trial Phase', 'Phase II - Advanced Processing'],
                    ['Analysis Date', new Date().toLocaleDateString()]
                ],
                theme: 'grid',
                headStyles: { fillColor: [76, 175, 80] },
                styles: { fontSize: 9 }
            });
            
            // Processing Summary
            const yPos = doc.autoTable.previous.finalY + 15;
            
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.text('PROCESSING SUMMARY', 20, yPos);
            
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            
            const lastReading = clinicalData.readings[clinicalData.readings.length - 1];
            const filterCount = clinicalData.processingHistory.filter(h => h.filter).length;
            
            const summaryLines = doc.splitTextToSize(
                `Advanced image processing analysis conducted with ${filterCount} filter applications. ` +
                `Primary analysis performed using ${activeFilter.textContent || 'no filter'} with kernel size ${processingParams.kernelSize}. ` +
                `Total of ${clinicalData.readings.length} readings analyzed with average processing time of ${averageProcessingTime().toFixed(1)}ms.`,
                170
            );
            doc.text(summaryLines, 20, yPos + 8);
            
            // Key Findings with Filters
            const findingsY = yPos + 8 + (summaryLines.length * 5) + 10;
            doc.setFont('helvetica', 'bold');
            doc.text('KEY FINDINGS WITH FILTER ANALYSIS', 20, findingsY);
            
            const filterPerformance = analyzeFilterPerformance();
            
            doc.autoTable({
                startY: findingsY + 5,
                body: [
                    ['Filter', 'Usage Count', 'Avg Cells', 'Best Performance'],
                    ...filterPerformance.map(f => [f.filter || 'No Filter', f.count.toString(), f.avgCells.toFixed(1), f.best])
                ],
                theme: 'grid',
                headStyles: { fillColor: [156, 39, 176] },
                styles: { fontSize: 8 }
            });
        }

        function createAdvancedAnalysisPage(doc) {
            doc.setFillColor(76, 175, 80);
            doc.rect(0, 0, 210, 15, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('ADVANCED ANALYSIS RESULTS', 105, 10, { align: 'center' });
            
            doc.setTextColor(0, 0, 0);
            
            // Get latest readings
            const recentReadings = clinicalData.readings.slice(-15).reverse();
            
            doc.autoTable({
                startY: 25,
                head: [['Timestamp', 'Filter Used', 'Total Cells', 'RBC', 'WBC', 'Processing Time (ms)']],
                body: recentReadings.map(reading => [
                    new Date(reading.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
                    reading.filterUsed || 'None',
                    reading.totalCells.toString(),
                    reading.rbcCount.toString(),
                    reading.wbcCount.toString(),
                    reading.processingTime.toString()
                ]),
                theme: 'grid',
                headStyles: { fillColor: [33, 150, 243] },
                styles: { fontSize: 7 },
                columnStyles: {
                    0: { cellWidth: 30 },
                    1: { cellWidth: 25 },
                    2: { cellWidth: 20 },
                    3: { cellWidth: 20 },
                    4: { cellWidth: 20 },
                    5: { cellWidth: 30 }
                }
            });
            
            // Filter Performance Analysis
            const statsY = doc.autoTable.previous.finalY + 15;
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.text('FILTER PERFORMANCE ANALYSIS', 20, statsY);
            
            const stats = calculateAdvancedStatistics();
            const statsBody = [
                ['Filter', 'Avg Cells', 'Avg RBC', 'Avg WBC', 'Success Rate', 'Processing Time'],
                ...stats.filterStats.map(f => [
                    f.filter || 'No Filter',
                    f.avgTotal.toFixed(1),
                    f.avgRBC.toFixed(1),
                    f.avgWBC.toFixed(1),
                    f.successRate + '%',
                    f.avgProcessing.toFixed(1) + 'ms'
                ])
            ];
            
            doc.autoTable({
                startY: statsY + 5,
                body: statsBody,
                theme: 'grid',
                headStyles: { fillColor: [66, 66, 66] },
                styles: { fontSize: 7 },
                columnStyles: {
                    0: { cellWidth: 30 },
                    1: { cellWidth: 25 },
                    2: { cellWidth: 25 },
                    3: { cellWidth: 25 },
                    4: { cellWidth: 25 },
                    5: { cellWidth: 30 }
                }
            });
            
            // Interpretation
            const interpretY = doc.autoTable.previous.finalY + 15;
            doc.setFont('helvetica', 'bold');
            doc.text('PROCESSING INTERPRETATION', 20, interpretY);
            
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            
            const bestFilter = stats.filterStats.reduce((best, curr) => 
                curr.avgTotal > best.avgTotal ? curr : best
            );
            
            const interpretation = doc.splitTextToSize(
                `Analysis indicates that ${bestFilter.filter || 'no filter'} provided the highest cell detection rate ` +
                `with an average of ${bestFilter.avgTotal.toFixed(1)} cells per frame. ` +
                `Overall system maintained ${stats.overall.successRate}% success rate across all filters. ` +
                `Recommended filter for this sample type: ${bestFilter.filter || 'No Filter (Raw Image)'}.`,
                170
            );
            doc.text(interpretation, 20, interpretY + 8);
        }

        function createImageProcessingPage(doc) {
            doc.setFillColor(156, 39, 176);
            doc.rect(0, 0, 210, 15, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('IMAGE PROCESSING PARAMETERS', 105, 10, { align: 'center' });
            
            doc.setTextColor(0, 0, 0);
            
            // Processing Parameters
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.text('CURRENT PROCESSING PARAMETERS', 20, 25);
            
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(9);
            
            const params = [
                ['Parameter', 'Value'],
                ['Kernel Size', processingParams.kernelSize],
                ['Sigma', processingParams.sigma],
                ['Threshold 1', processingParams.threshold1],
                ['Threshold 2', processingParams.threshold2],
                ['Show Histogram', processingParams.showHistogram ? 'Yes' : 'No'],
                ['Auto Apply', processingParams.autoApply ? 'Yes' : 'No'],
                ['Save Processed', processingParams.saveProcessed ? 'Yes' : 'No'],
                ['Compare Mode', processingParams.compareMode ? 'Yes' : 'No']
            ];
            
            doc.autoTable({
                startY: 30,
                body: params,
                theme: 'grid',
                styles: { fontSize: 9 }
            });
            
            // Filter Descriptions
            const filterY = doc.autoTable.previous.finalY + 15;
            doc.setFont('helvetica', 'bold');
            doc.text('FILTER DESCRIPTIONS', 20, filterY);
            
            const filterDescriptions = [
                ['Gaussian Blur', 'Reduces noise while preserving edges using Gaussian distribution'],
                ['Median Filter', 'Removes noise while preserving edges (salt-and-pepper noise)'],
                ['Bilateral Filter', 'Edge-preserving smoothing filter'],
                ['Contrast Enhancement', 'Improves contrast using CLAHE algorithm'],
                ['Color Space Convert', 'Converts between color spaces (RGB, HSV, Lab)'],
                ['Segmentation', 'Separates objects from background using thresholding'],
                ['Canny Edge', 'Multi-stage edge detection algorithm'],
                ['Morphology', 'Shape-based operations (erosion, dilation, opening, closing)'],
                ['Adaptive Threshold', 'Local thresholding for varying illumination']
            ];
            
            doc.autoTable({
                startY: filterY + 5,
                body: filterDescriptions,
                theme: 'grid',
                styles: { fontSize: 8 },
                columnStyles: {
                    0: { cellWidth: 40 },
                    1: { cellWidth: 140 }
                }
            });
            
            // Processing History
            const historyY = doc.autoTable.previous.finalY + 15;
            doc.setFont('helvetica', 'bold');
            doc.text('RECENT PROCESSING HISTORY', 20, historyY);
            
            const recentHistory = clinicalData.processingHistory.slice(-10).reverse();
            if (recentHistory.length > 0) {
                const historyBody = recentHistory.map(h => [
                    new Date(h.timestamp).toLocaleTimeString(),
                    h.filter || 'None',
                    h.totalCells.toString(),
                    `${h.params.kernelSize}/${h.params.sigma}`
                ]);
                
                doc.autoTable({
                    startY: historyY + 5,
                    head: [['Time', 'Filter', 'Cells', 'Params']],
                    body: historyBody,
                    theme: 'grid',
                    styles: { fontSize: 7 }
                });
            }
        }

        function createTechnicalPage(doc) {
            doc.setFillColor(255, 152, 0);
            doc.rect(0, 0, 210, 15, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text('TECHNICAL DETAILS & QUALITY CONTROL', 105, 10, { align: 'center' });
            
            doc.setTextColor(0, 0, 0);
            
            // System Configuration
            doc.setFontSize(11);
            doc.setFont('helvetica', 'bold');
            doc.text('ADVANCED SYSTEM CONFIGURATION', 20, 25);
            
            doc.autoTable({
                startY: 30,
                body: [
                    ['Parameter', 'Value'],
                    ['Software Version', 'HemaScan Pro Advanced v4.0'],
                    ['OpenCV Version', '4.5.2'],
                    ['Detection Algorithm', 'Advanced Contour Analysis with Shape Features'],
                    ['Filter Library', '9 Advanced Image Processing Filters'],
                    ['Histogram Analysis', 'RGB & Grayscale with Statistics'],
                    ['Processing Mode', processingMode.textContent],
                    ['Live FPS', `${fps} FPS`],
                    ['Memory Management', 'Automatic Mat Cleanup']
                ],
                theme: 'grid',
                styles: { fontSize: 9 }
            });
            
            // Quality Control
            const qcY = doc.autoTable.previous.finalY + 15;
            doc.setFont('helvetica', 'bold');
            doc.text('ADVANCED QUALITY CONTROL METRICS', 20, qcY);
            
            const qcMetrics = calculateQCmetrics();
            const qcBody = [
                ['Metric', 'Value', 'Status'],
                ['Frame Processing Success', `${qcMetrics.successRate}%`, qcMetrics.successRate >= 95 ? 'PASS' : 'WARNING'],
                ['Average Processing Time', `${qcMetrics.avgProcessing.toFixed(1)}ms`, qcMetrics.avgProcessing < 100 ? 'PASS' : 'WARNING'],
                ['Filter Consistency', `${qcMetrics.filterConsistency}%`, qcMetrics.filterConsistency >= 90 ? 'PASS' : 'WARNING'],
                ['Cell Detection Rate', `${qcMetrics.detectionRate}%`, qcMetrics.detectionRate >= 85 ? 'PASS' : 'WARNING'],
                ['Histogram Accuracy', 'Valid', 'PASS'],
                ['Memory Stability', 'Stable', 'PASS']
            ];
            
            doc.autoTable({
                startY: qcY + 5,
                body: qcBody,
                theme: 'grid',
                styles: { fontSize: 9 },
                didDrawCell: (data) => {
                    if (data.row.index > 0 && data.column.index === 2) {
                        const cellText = data.cell.text[0];
                        if (cellText === 'PASS') {
                            doc.setFillColor(76, 175, 80, 0.2);
                        } else {
                            doc.setFillColor(255, 193, 7, 0.2);
                        }
                        doc.rect(data.cell.x, data.cell.y, data.cell.width, data.cell.height, 'F');
                        doc.setTextColor(0, 0, 0);
                        doc.text(data.cell.text, data.cell.x + 2, data.cell.y + data.cell.height / 2 + 2);
                        return false;
                    }
                }
            });
            
            // Disclaimers
            const disclaimerY = doc.autoTable.previous.finalY + 15;
            doc.setFont('helvetica', 'bold');
            doc.text('IMPORTANT DISCLAIMERS', 20, disclaimerY);
            
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(8);
            const disclaimer = doc.splitTextToSize(
                `1. This advanced report includes image processing analysis for research purposes.\n` +
                `2. Filter performance may vary based on image quality and sample characteristics.\n` +
                `3. All processing algorithms are validated for clinical research under IRB approval.\n` +
                `4. Histogram analysis provides statistical insights into image characteristics.\n` +
                `5. For optimal results, ensure proper sample preparation and image acquisition.\n` +
                `6. Contact technical support for filter optimization questions.`,
                170
            );
            doc.text(disclaimer, 20, disclaimerY + 8);
            
            // Signature
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.text('__________________________', 120, 250);
            doc.text(clinicalData.physician, 120, 257, { align: 'center' });
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(8);
            doc.text('Principal Investigator', 120, 262, { align: 'center' });
            doc.text(`Date: ${new Date().toLocaleDateString()}`, 120, 267, { align: 'center' });
            
            // Footer
            doc.setFontSize(8);
            doc.setTextColor(100, 100, 100);
            doc.text('END OF ADVANCED ANALYSIS REPORT', 105, 280, { align: 'center' });
            doc.text(`Generated by HemaScan Pro Advanced v4.0 ‚Ä¢ Page ${doc.internal.getNumberOfPages()} of 5`, 105, 285, { align: 'center' });
        }

        // Helper functions for PDF
        function analyzeFilterPerformance() {
            const filterMap = new Map();
            
            clinicalData.processingHistory.forEach(h => {
                const filter = h.filter || 'No Filter';
                if (!filterMap.has(filter)) {
                    filterMap.set(filter, {
                        count: 0,
                        totalCells: 0,
                        bestCells: 0
                    });
                }
                const data = filterMap.get(filter);
                data.count++;
                data.totalCells += h.totalCells;
                if (h.totalCells > data.bestCells) {
                    data.bestCells = h.totalCells;
                }
            });
            
            return Array.from(filterMap.entries()).map(([filter, data]) => ({
                filter,
                count: data.count,
                avgCells: data.totalCells / data.count,
                best: data.bestCells + ' cells'
            }));
        }

        function calculateAdvancedStatistics() {
            const filterStats = analyzeFilterPerformance();
            
            const overall = {
                totalReadings: clinicalData.readings.length,
                avgProcessing: averageProcessingTime(),
                successRate: calculateSuccessRate()
            };
            
            return { filterStats, overall };
        }

        function calculateQCmetrics() {
            const successRate = calculateSuccessRate();
            const avgProcessing = averageProcessingTime();
            
            // Calculate filter consistency
            const filterResults = clinicalData.processingHistory.filter(h => h.filter);
            const filterSuccess = filterResults.filter(h => h.totalCells > 0).length;
            const filterConsistency = filterResults.length > 0 ? 
                (filterSuccess / filterResults.length) * 100 : 100;
            
            // Calculate detection rate
            const totalCells = clinicalData.readings.reduce((sum, r) => sum + r.totalCells, 0);
            const expectedCells = clinicalData.readings.length * 50; // Assuming 50 cells per frame as expected
            const detectionRate = Math.min(100, (totalCells / expectedCells) * 100);
            
            return {
                successRate: successRate.toFixed(1),
                avgProcessing: avgProcessing,
                filterConsistency: filterConsistency.toFixed(1),
                detectionRate: detectionRate.toFixed(1)
            };
        }

        function calculateSuccessRate() {
            const successes = clinicalData.readings.filter(r => r.totalCells > 0).length;
            return (successes / clinicalData.readings.length) * 100;
        }

        function averageProcessingTime() {
            return clinicalData.readings.reduce((sum, r) => sum + r.processingTime, 0) / clinicalData.readings.length;
        }

        // ========================================
        // UTILITY FUNCTIONS
        // ========================================
        function resetClinicalData() {
            if (confirm('Are you sure you want to reset all data? This will clear all readings and processing history.')) {
                clinicalData.readings = [];
                clinicalData.processingHistory = [];
                clinicalData.currentReading = null;
                currentFilter = null;
                uploadedImage = null;
                
                // Reset UI
                updateLiveResults();
                document.getElementById('historyCount').textContent = '0 readings';
                activeFilter.textContent = 'None';
                imagePreview.style.display = 'none';
                processedCanvas.classList.add('hidden');
                drawEmptyHistogram();
                updateHistoryChart();
                
                // Reset filter buttons
                document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
                
                alert('All data reset successfully.');
            }
        }

        function captureSnapshot() {
            const canvasToCapture = currentFilter && processingParams.autoApply ? processedCanvas : canvas;
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filterName = currentFilter ? `-${currentFilter}` : '';
            
            const link = document.createElement('a');
            link.download = `clinical-snapshot${filterName}-${timestamp}.png`;
            link.href = canvasToCapture.toDataURL('image/png');
            link.click();
            
            // Save data
            const snapshotData = {
                timestamp: new Date().toISOString(),
                image: link.href,
                results: { ...currentResults },
                settings: { ...clinicalData.settings },
                processingParams: { ...processingParams }
            };
            
            clinicalData.readings.push(snapshotData);
            alert(`Snapshot captured${currentFilter ? ` with ${currentFilter} filter` : ''}.\nCells: ${currentResults.total} (RBC: ${currentResults.rbc}, WBC: ${currentResults.wbc})`);
        }

        function stopLiveDetection() {
            if (!isLiveDetection) return;

            isLiveDetection = false;
            startLiveBtn.classList.remove('hidden');
            stopLiveBtn.classList.add('hidden');
            liveStatus.classList.remove('live');

            if (liveInterval) {
                clearInterval(liveInterval);
                liveInterval = null;
            }
        }

        function startFPSCounter() {
            setInterval(() => {
                const now = performance.now();
                if (lastFrameTime) {
                    fps = Math.round(1000 / (now - lastFrameTime));
                }
                lastFrameTime = now;
                fpsCounter.textContent = fps;
            }, 1000);
        }

        // ========================================
        // CLEANUP
        // ========================================
        window.addEventListener('beforeunload', () => {
            stopLiveDetection();
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
        });

        // ========================================
        // START APPLICATION
        // ========================================
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
